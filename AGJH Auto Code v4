#include <xmotion.h>
//https://blog.jsumo.com/xmotion-basics-xmotion-101/
#include <NewPing.h>
//https://bitbucket.org/teckel12/arduino-new-ping/wiki/Home

// ----- Pin Definitions & Constants -----
const int ML_Sensor_Left   = A5;    // Left line sensor
const int ML_Sensor_Center = A4;    // Center line sensor (ideally centered)
const int ML_Sensor_Right  = A2;    // Right line sensor

int MoveForwardDelay = 200;
int PivotDelay = 200;
int BASE_SPEED = 20;
int WALL_DISTANCE = 18;

//Buttons
#define START_BUTTON         10   // Button to start
#define START_DELAY     5000      //  5 seconds

//Ultrasonic
#define MAX_DISTANCE 200
NewPing US_LEFT(1,1, MAX_DISTANCE);
NewPing US_CENTER(2,2, MAX_DISTANCE);
NewPing US_RIGHT(4,4, MAX_DISTANCE);

// Enum to handle the robot's state
enum RobotState {
  WAIT_BUTTON,
  LINE_FOLLOW,  
  PIVOT_180,     
  SEARCH_LINE,   
  WALL_CHECK     
};

unsigned long debounceStart = 0;
unsigned long lostLineTimer = 0;

RobotState currentState = WAIT_BUTTON;

// ----- Setup -----
void setup() {
  // Initialize sensor pins
  pinMode(ML_Sensor_Left, INPUT);
  pinMode(ML_Sensor_Center, INPUT);
  pinMode(ML_Sensor_Right, INPUT);

  //Start Button
  pinMode(START_BUTTON, INPUT);

  // Initialize motor control pins here
  // e.g., pinMode(pwmLeft, OUTPUT); pinMode(dirLeft, OUTPUT); etc.
  
  // Initialize serial monitor for debugging if needed
  Serial.begin(9600);
}

// ----- Main Loop -----
void loop() {
  switch (currentState) {

    case WAIT_BUTTON:
      // Wait for the button to be pressed.
      if (digitalRead(START_BUTTON) == LOW) {
      // Block until the button is released.
      while (digitalRead(START_BUTTON) == LOW) {
        delay(10); // Small delay to avoid busy-waiting.
      }
      //Delay Robot length of START_DELAY variable
      delay(START_DELAY);
      currentState = LINE_FOLLOW;
      }
    break;
    
    case LINE_FOLLOW:
      followLine();  
      // If all sensors lose the line, transition to pivot.
      if (lineEndDetected()) {
        stopMotors();
        delay(100);
        currentState = PIVOT_180;
      }
      break;

    case PIVOT_180:
      pivot180();
      delay(100);
      currentState = SEARCH_LINE;
      break;

    case SEARCH_LINE:
      findLine();
      // Once the line is found, return to line following.
      currentState = LINE_FOLLOW;
      break;

    case WALL_CHECK:
      if (checkWallConditions()) {
        // If wall conditions are met, pivot and restart the cycle.
        pivot180();
        delay(100);
        currentState = LINE_FOLLOW;
      } else {
        stopMotors();
        while (1);  // Halt; alternatively, add error handling.
      }
      break;
  }
}

// ----- Core Functions -----
// This followLine function assumes an ideal sensor placement.
// It drives forward if the center sensor is active, otherwise adjusts using the side sensors.
void followLine() {
  bool leftActive   = digitalRead(ML_Sensor_Left);
  bool centerActive = digitalRead(ML_Sensor_Center);
  bool rightActive  = digitalRead(ML_Sensor_Right);

  if (centerActive) {  
    moveForward();
  } else if (leftActive && !rightActive) {
    turnLeft();
  } else if (rightActive && !leftActive) {
    turnRight();
  } else {
    // No sensor active; likely the line is lost.
    stopMotors();
  }
}

// Returns true if none of the line sensors detect the line.
bool lineEndDetected() {
  return (!digitalRead(ML_Sensor_Left) &&
          !digitalRead(ML_Sensor_Center) &&
          !digitalRead(ML_Sensor_Right));
}

// Pivot the robot 180° (example using a left pivot; adjust delay for your robot).
void pivot180() {
  pivotLeft();   // Implement pivotLeft() to rotate in place and find line
}

// In SEARCH_LINE, use ultrasonic sensors to help center the robot as it moves forward
// until one of the line sensors detects the line.
void findLine() {
  unsigned long startTime = millis();
  const int timeout = 5000;    // Timeout period (ms)
  const float threshold = 3; // Threshold (cm) for ultrasonic difference

  while (!digitalRead(ML_Sensor_Left) &&
         !digitalRead(ML_Sensor_Center) &&
         !digitalRead(ML_Sensor_Right)) {

    // Read left and right ultrasonic sensor distances (in cm)
    float leftDistance = US_LEFT.ping_cm();;
    float rightDistance = US_RIGHT.ping_cm();;

    float error = leftDistance - rightDistance;

    if (error > threshold) {
      // Left side is farther from the reference than right—adjust by turning slightly left.
      turnLeft();
    } else if (error < -threshold) {
      // Right side is farther—adjust by turning slightly right.
      turnRight();
    } else {
      // Readings are balanced; move forward.
      moveForward();
    }

    // Exit if timeout is reached to prevent getting stuck.
    if (millis() - startTime > timeout) {

      break;
    }
  }
  
  stopMotors(); // Stop once any line sensor is triggered.
}

// Check ultrasonic sensors when reaching the starting wall.
// Left ultrasonic should read > WALL_DISTANCE, while front and right are < WALL_DISTANCE".
bool checkWallConditions() {
  float leftDist  = US_LEFT.ping_cm();
  float frontDist = US_CENTER.ping_cm();
  float rightDist = US_RIGHT.ping_cm();
 
  //Comment one of the following return statments for use of ultrasonic sensors
  //return (leftDist > WALL_DISTANCE && frontDist < WALL_DISTANCE && rightDist < WALL_DISTANCE);
   return false;
}

// ----- Motor Control Functions -----

void moveForward() {
xmotion.Forward(BASE_SPEED,200);
}

void turnLeft() {
// Left Motor BASE_SPEED-5, Right Motor BASE_SPEED+5, duration 50 ms. Right spins faster and moves robot left.
// xmotion.ArcTurn(LeftSpeed,RightSpeed,duration)
xmotion.ArcTurn(BASE_SPEED-5,BASE_SPEED+5,50);
}

void turnRight() {
// Left Motor BASE_SPEED+5, Right Motor BASE_SPEED-5, duration 50 ms. Left spins faster and moves robot right.
// xmotion.ArcTurn(LeftSpeed,RightSpeed,duration)
xmotion.ArcTurn(BASE_SPEED+5,BASE_SPEED-5,50);
}

void pivotLeft() {
xmotion.StopMotors(200);
xmotion.Forward(BASE_SPEED, 200); //Attempt to push out snowball
xmotion.Backward(BASE_SPEED, 1000);
while (!digitalRead(ML_Sensor_Left)){
  xmotion.ArcTurn(-50,50,100);
  }
findLine();
}

void stopMotors() {
xmotion.StopMotors(30);
}


